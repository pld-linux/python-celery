From 810b72e9d3f3d3c9af0d0e13df8c681f8d692ab8 Mon Sep 17 00:00:00 2001
From: Dennis Brakhane <dennis.brakhane@inoio.de>
Date: Fri, 30 Oct 2015 20:05:11 +0100
Subject: [PATCH] Fix LRUCache.update for Python 3.5

Python 3.5's OrderedDict does not allow mutation while it is being
iterated over. This breaks "update" if it is called with a dict
larger than the maximum size.

This commit changes the code to a version that does not iterate over
the dict, and should also be a little bit faster.

Closes #2897
---
 CONTRIBUTORS.txt                      | 1 +
 celery/tests/utils/test_functional.py | 5 +++++
 celery/utils/functional.py            | 7 +++----
 3 files changed, 9 insertions(+), 4 deletions(-)

diff --git a/celery/tests/utils/test_functional.py b/celery/tests/utils/test_functional.py
index c60419d..043646f 100644
--- a/celery/tests/utils/test_functional.py
+++ b/celery/tests/utils/test_functional.py
@@ -63,6 +63,11 @@ def test_least_recently_used(self):
         x[7] = 7
         self.assertEqual(list(x.keys()), [3, 6, 7])
 
+    def test_update_larger_than_cache_size(self):
+        x = LRUCache(2)
+        x.update({x: x for x in range(100)})
+        self.assertEqual(list(x.keys()), [98, 99])
+
     def assertSafeIter(self, method, interval=0.01, size=10000):
         if sys.version_info >= (3, 5):
             raise SkipTest('Fails on Py3.5')
diff --git a/celery/utils/functional.py b/celery/utils/functional.py
index fbb4fc4..1af2914 100644
--- a/celery/utils/functional.py
+++ b/celery/utils/functional.py
@@ -20,7 +20,7 @@
 from kombu.utils import cached_property
 from kombu.utils.functional import lazy, maybe_evaluate, is_list, maybe_list
 
-from celery.five import UserDict, UserList, items, keys
+from celery.five import UserDict, UserList, items, keys, range
 
 __all__ = ['LRUCache', 'is_list', 'maybe_list', 'memoize', 'mlazy', 'noop',
            'first', 'firstmethod', 'chunks', 'padlist', 'mattrgetter', 'uniq',
@@ -71,9 +71,8 @@ def update(self, *args, **kwargs):
             data.update(*args, **kwargs)
             if limit and len(data) > limit:
                 # pop additional items in case limit exceeded
-                # negative overflow will lead to an empty list
-                for item in islice(iter(data), len(data) - limit):
-                    data.pop(item)
+                for _ in range(len(data) - limit):
+                    data.popitem(last=False)
 
     def popitem(self, last=True):
         with self.mutex:
